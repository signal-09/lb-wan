#!/bin/bash

set -eo pipefail

# load shared components
SCRIPT=$(realpath -- "${BASH_SOURCE[0]}")
BINDIR=$(dirname -- "$SCRIPT")
COMMON="${BINDIR}/common.sh"
source "$COMMON" || exit 255


# delete status files on exit
cleanup() {
    while read PROVIDER ETHERNET WEIGHT PING_IPS; do
        STATUS_FILE="${RUNSTATEDIR}/lb_${PROVIDER,,}.status"
        [[ -f "$STATUS_FILE" ]] && rm -f "$STATUS_FILE" || :
    done <<<"$WAN_CONF"
    exit
}
trap cleanup INT TERM


# ping with ethernet binding and return RTTs if succeded
rtt_ping() {
    local PROVIDER=$1
    local TARGET=$2

    ip vrf exec "${PROVIDER,,}" ping -4 -q -c1 -n -W${PING_TIMEOUT} ${TARGET} 2>/dev/null | awk -F/ '/^rtt/{ print $5 }'
}


# write status file based on reachability
check_connectivity() {
    local PROVIDER=$1
    local TARGETS=$2
    local REACHED=false

    # check for reachability
    for TGT in ${TARGETS//,/ }; do
        if RTT=$(rtt_ping ${PROVIDER} ${TGT}); then
            REACHED=true
            break
        fi
    done

    # get last connection status
    read LOSS OLD_RTT OLD_STATE < <(get_wan_status "$PROVIDER")
    debug "${PROVIDER}: LOSS=${LOSS} RTT=${OLD_RTT} STATE=${OLD_STATE}"

    # adapt status value
    if [[ $REACHED == true ]]; then
        if [[ $LOSS -gt 0 ]]; then
            LOSS=$[LOSS - 1]
            STATE=$OLD_STATE
        else
            STATE='UP'
        fi
    else
        if [[ $LOSS -lt $MAX_PACKET_LOSS ]]; then
            LOSS=$[LOSS + 1]
            STATE=$OLD_STATE
        else
            STATE='DOWN'
        fi
    fi

    # save status
    [[ "$STATE" == "$OLD_STATE" ]] || log "Declaring ${PROVIDER} ${STATE}"
    set_wan_status "$PROVIDER" "$LOSS" "$RTT" "$STATE"
}


while sleep $MON_CHECK_INTERVAL; do
    while read PROVIDER ETHERNET WEIGHT PING_IPS; do
        # asyncronous check
        check_connectivity $PROVIDER $PING_IPS &
    done <<<"$WAN_CONF"
done
